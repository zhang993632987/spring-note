# 3.3.1 构建docker镜像

## 1. 添加docker的Maven插件

```xml
<plugin>
    <groupId>com.spotify</groupId>
    <artifactId>dockerfile-maven-plugin</artifactId>
    <version>1.4.13</version>
    <configuration>
        <repository>${docker.image.prefix}/${project.artifactId}</repository>
        <tag>${project.version}</tag>
        <buildArgs>
            <JAR_FILE>target/${project.build.finalName}.jar</JAR_FILE>
        </buildArgs>
    </configuration>
    <executions>
        <execution>
            <id>default</id>
            <phase>install</phase>
            <goals>
                <goal>build</goal>
                <goal>push</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

## 2. 添加docker.image.prefix属性值

```xml
<properties>
    <java.version>11</java.version>
    <docker.image.prefix>192.168.10.110:50000</docker.image.prefix>
</properties>
```

除了直接在pom.xml中定义外，还可以在执行maven命令时通过 **-d** 传递docker.image.prefix属性值。

## 3. 编写Dockerfile

存在两种Dockerfile的编写方式，分别是**基本Dockerfile**和**多阶段Dockerfile**。

* 使用基本Dockerfile，你将复制Spring Boot微服务的整个JAR文件；
* 而使用多阶段构建，你将只复制应用程序必需的内容。

{% hint style="warning" %}
Dockerfile文件的存放路径与pom.xml同级！

<img src="../../../.gitbook/assets/image (5).png" alt="" data-size="original">
{% endhint %}

### 基础Dockerfile

```docker
#从包含Java运行时的基本镜像开始
FROM openjdk:11-slim

# 添加维护人员信息
LABEL maintainer="bohan zhang <bohanz838@gmail.com>"

# 应用程序的JAR文件
ARG JAR_FILE
# 将应用程序的JAR文件添加到容器中
COPY ${JAR_FILE} app.jar

#执行应用程序
ENTRYPOINT ["java", "-jar", "/app.jar"]
```

### 多阶段Dockerfile

多阶段构建允许我们丢弃对应用程序执行不重要的所有东西。例如，在Spring Boot中，我们不需要将整个目标文件夹复制到Docker镜像中，我们只需要复制运行Spring Boot应用程序所需的内容。这种方式将优化我们创建的Docker镜像。

{% code overflow="wrap" %}
```docker
#阶段 1
#从包含Java运行时的基本镜像开始
FROM openjdk:11-slim as build

# 添加维护人员信息
LABEL maintainer="bohan zhang <bohanz838@gmail.com>"

# 应用程序的JAR文件
ARG JAR_FILE

# 将应用程序的JAR文件添加到容器中
COPY ${JAR_FILE} app.jar

# 解包JAR文件
RUN mkdir -p target/dependency &&
    (cd target/dependency; jar -xf /app.jar)
    
#阶段2   
#相同的Java运行时
FROM openjdk:11-slim

#添加指向/tmp的数据卷
VOLUME /tmp 

#将未打包的应用程序复制到新的容器
ARG DEPENDENCY=/target/dependency
COPY --from=build ${DEPENDENCY}/BOOT-INF/lib /app/lib
COPY --from=build ${DEPENDENCY}/META-INF /app/META-INF
COPY --from=build ${DEPENDENCY}/BOOT-INF/classes /app

#执行应用程序
ENTRYPOINT ["java", "-cp" ,"app:app/lib/*", "com.study.cloudlearning.CloudLearningApplication"]
```
{% endcode %}

在**阶段1**中，通过使用FROM命令，Dockerfile从openJDK镜像创建一个名为build的镜像，该镜像针对Java应用程序优化过。这个镜像负责创建和解包JAR应用程序文件。接下来，Dockerfile获取我们在pom.xml的节点中设置的JAR\_FILE变量的值。然后，我们将JAR文件以app.jar复制到镜像文件系统中，并将其解包，以公开一个Spring Boot应用程序包含的不同分层。

一旦公开了不同的分层，Dockerfile将创建另一个镜像，该镜像将只包含这些分层，而不是完整的应用程序JAR。在**阶段2**中，Dockerfile将不同的层复制到新镜像中。最后，ENTRYPOINT命令允许我们在容器创建完成时以镜像中的许可证服务应用程序为目标。

{% hint style="info" %}
<mark style="color:blue;">**如果我们不改变项目的依赖项，BOOT-INF/lib文件夹就不会改变。此文件夹包含运行应用程序所需的所有内部和外部依赖项。**</mark>
{% endhint %}

## 4. 构建镜像

执行**mvn clean package dockerfile:build**命令对应用构建镜像。
